import asyncio
import os
import re
import signal
import sys
from pathlib import Path
from typing import Literal

from jinja2 import Environment
from pydantic import IPvAnyAddress

from app.dto import Flow, FlowRateLimit, Neighbor, Route

CONFIG_TEMPLATE = """\
# DO NOT EDIT THIS FILE MANUALLY
# This file is generated by exabgp-api

process http-api {
    run /opt/exabgp/run.sh;
    encoder json;
}

template {
    neighbor cores {
        api services {
            processes [ http-api ];
        }
    }
}\
"""

NEIGHBOR_TEMPLATE = """\
#begin_{{ neighbor.ip_address }}:
neighbor {{ neighbor.ip_address }} {
    inherit cores;

    {%- if neighbor.description is not none %}
    description {{ neighbor.description }};
    {%- endif %}

    {%- if neighbor.router_id is not none %}
    router-id {{ neighbor.router_id }};
    {%- endif %}

    {%- if neighbor.local_address is not none %}
    local-address {{ neighbor.local_address }};
    {%- endif %}

    {%- if neighbor.local_as is not none %}
    local-as {{ neighbor.local_as }};
    {%- endif %}

    {%- if neighbor.peer_as is not none %}
    peer-as {{ neighbor.peer_as }};
    {%- endif %}

    {%- if neighbor.connect is not none %}
    connect {{ neighbor.connect }};
    {%- endif %}

    {%- if neighbor.capability is not none %}
    capability {
        {%- if neighbor.capability.route_refresh %}
        route-refresh;
        {%- endif %}
    }
    {%- endif %}
}
#end\
"""

# we use a lock to read the response from stdin before executing another command.
lock = asyncio.Lock()


def reload() -> None:
    os.kill(os.getppid(), signal.SIGUSR1)


async def send_command(command: str) -> bool:
    async with lock:
        sys.stdin.flush()

        sys.stdout.write(f"{command}\n")
        sys.stdout.flush()

        result = sys.stdin.readline().strip()

        return result == "done"


def update_config(
    path: Path, key: IPvAnyAddress, value: Neighbor | None = None
) -> bool:
    config = path.read_text()

    neighbors = {
        m.group(1): m.group(0)
        for m in re.finditer(
            r"#begin_(.+?):\n(.+?)#end", config, re.DOTALL | re.MULTILINE
        )
    }

    key_ = str(key)
    exists = key_ in neighbors

    env = Environment()
    template = env.from_string(NEIGHBOR_TEMPLATE)

    if value is None:
        neighbors.pop(key_, None)
    else:
        neighbors[key_] = template.render(neighbor=value)

    with path.open("w") as fp:
        fp.write("\n\n".join([CONFIG_TEMPLATE, *neighbors.values()]))

    return exists


def flow_to_command(
    neighbor: IPvAnyAddress, type: Literal["announce", "withdraw"], flow: Flow
) -> str:
    command: list[str] = ["neighbor", str(neighbor), type, "flow", "route"]

    for k, v in (
        ("source", flow.match.source),
        ("destination", flow.match.destination),
        ("port", flow.match.port),
        ("source-port", flow.match.source_port),
        ("destination-port", flow.match.destination_port),
        ("protocol", flow.match.protocol),
        ("tcp-flags", flow.match.tcp_flags),
        ("icmp-type", flow.match.icmp_type),
        ("icmp-code", flow.match.icmp_code),
        ("fragment", flow.match.fragment),
        ("packet-length", flow.match.packet_length),
    ):
        if v is not None:
            command.extend([k, str(v)])

    if isinstance(flow.then, FlowRateLimit):
        command.extend(["rate-limit", str(flow.then.rate_limit)])
    else:
        command.append(flow.then)

    return " ".join(command)


def route_to_command(
    neighbor: IPvAnyAddress, type: Literal["announce", "withdraw"], route: Route
) -> str:
    command: list[str] = [
        "neighbor",
        str(neighbor),
        type,
        "route",
        str(route.prefix),
        "next-hop",
        str(route.next_hop),
    ]

    if route.community is not None and len(route.community) > 0:
        command.append("community")

        for i in route.community:
            command.append(f"{i[0]}:{i[1]}")

    return " ".join(command)
